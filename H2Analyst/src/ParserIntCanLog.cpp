#include "Parsers.h"

/*

This file contains the parser for MAT-files as they are generated by the Forze cars.
It reads the file as a binary stream and reads the StartTime, Datasets and Messages structs in the file.
"https://maxwell.ict.griffith.edu.au/spl/matlab-page/matfile_format.pdf" describes how the MAT-file is built.

*/


struct Tag {
	uint32_t type, size;
	bool small;
};


// Convenience function to copy n bytes to a target char array and increment the cursor accordingly.
void CopyBytes(char* source, char* dest, size_t &cursor, uint32_t n_bytes)
{
	memcpy(dest, &source[cursor], n_bytes);
	cursor += n_bytes;
}


// Function used to read a given filetype from a byte buffer
template <typename T>
T ReadRaw(char* buffer, const bool& byte_swap) {
	T result;
	char b[sizeof(T)];
	// Read bytes into array. If byte_swap is true, reverse order.
	for (size_t i = 0; i < sizeof(T); i++) {
		if (!byte_swap) b[sizeof(T) - i - 1] = static_cast<unsigned char>(buffer[i]);
		else b[i] = static_cast<unsigned char>(buffer[i]);
	}
	// Convert byte array to requested type by copying the array into the memory location of the result
	memcpy(&result, &b, sizeof(T));
	return result;
}


// Reads a single tag as used by the MAT-file format
Tag ReadTag(char* buffer, const bool& byte_swap)
{
	Tag tag = {0, 0, false};

	// Check if element is small format
	if (byte_swap) tag.small = (buffer[2] == 0 && buffer[3] == 0) ? false : true;
	else tag.small = (buffer[0] == 0 && buffer[1] == 0) ? false : true;

	if (!tag.small) {
		tag.type = ReadRaw<uint32_t>(&buffer[0], byte_swap);
		tag.size = ReadRaw<uint32_t>(&buffer[4], byte_swap);
	}
	else {
		// Type and size are reversed in the Forze MAT-file generation w.r.t. the standard
		tag.size = static_cast<uint32_t>(ReadRaw<uint16_t>(&buffer[2], byte_swap));
		tag.type = static_cast<uint32_t>(ReadRaw<uint16_t>(&buffer[0], byte_swap));
	}

	return tag;
}


// This function reads an element
template <typename T>
std::vector<T> ReadElement(char* buffer, size_t& cursor, const bool& byte_swap) {

	Tag tag = ReadTag(&buffer[cursor], byte_swap);
	uint8_t tag_size = (tag.small) ? 4 : 8;

	std::vector<T> data;
	for (size_t i = tag_size; i < (tag.size + tag_size); i += sizeof(T))
		data.push_back(ReadRaw<T>(&buffer[cursor + i], byte_swap));

	if (tag.small)
	{
		cursor += 8;
	}
	else cursor += (8 + (ceil(tag.size / 8.0) * 8));

	return data;
}


void ReadDatasetElement(char* buffer, size_t& cursor, H2A::Datafile* df, const bool& uid_defined, const bool& byte_swap) {

	H2A::Dataset* ds = new H2A::Dataset;
	ds->mutex.lock(); // Make sure this dataset can not be read untill we are with it in this function
	
	ds->datafile = df;

	uint8_t uid_field_offset = (uid_defined) ? 1 : 0;			// if UID is included in file, it offsets some positions

	// Iterate through fields
	for (int i = 0; i < 9 + uid_field_offset; i++) {

		/*
		ReadRaw<uint16_t>(&buffer[cursor + 4], byte_swap);	// element size
		cursor += 8;										// padding
		ReadElement<uint16_t>(buffer, cursor, byte_swap);	// flags
		ReadElement<int16_t>(buffer, cursor, byte_swap);	// dimensions
		cursor += 8;										// name (always empty)
		*/

		Tag tag = ReadTag(&buffer[cursor], byte_swap);
		cursor += 8;
		std::vector<uint32_t> flags = ReadElement<uint32_t>(buffer, cursor, byte_swap);
		std::vector<int32_t> dimensions = ReadElement<int32_t>(buffer, cursor, byte_swap);
		std::vector<char> name = ReadElement<char>(buffer, cursor, byte_swap); // This name is empty because its a matrix within a struct

		std::vector<char> temp_char;
		if (i == 0) {
			ds->id = ReadElement<uint16_t>(buffer, cursor, byte_swap)[0];
		}
		else if (i == 1) {
			temp_char = ReadElement<char>(buffer, cursor, byte_swap);
			ds->name = std::string(temp_char.begin(), temp_char.end());
		}
		else if (uid_defined && i == 2) {
			ds->uid = ReadElement<uint32_t>(buffer, cursor, byte_swap)[0];
		}
		else if (i == 2 + uid_field_offset) {
			temp_char = ReadElement<char>(buffer, cursor, byte_swap);
			ds->quantity = std::string(temp_char.begin(), temp_char.end());
		}
		else if (i == 3 + uid_field_offset) {
			temp_char = ReadElement<char>(buffer, cursor, byte_swap);
			ds->unit = std::string(temp_char.begin(), temp_char.end());
		}
		else if (i == 4 + uid_field_offset) {
			ds->length= ReadElement<uint8_t>(buffer, cursor, byte_swap)[0];
		}
		else if (i == 5 + uid_field_offset) {
			ds->byteOffset = ReadElement<uint8_t>(buffer, cursor, byte_swap)[0];
		}
		else if (i == 6 + uid_field_offset) {
			ds->datatype = ReadElement<uint8_t>(buffer, cursor, byte_swap)[0];
		}
		else if (i == 7 + uid_field_offset) {
			ds->offset = ReadElement<float>(buffer, cursor, byte_swap)[0];
		}
		else if (i == 8 + uid_field_offset) {
			ds->scale = ReadElement<float>(buffer, cursor, byte_swap)[0];
		}
		
	}

	/*
	if (!uid_defined)
	{
		cout << "No UIDs logged. Using lookup file" << endl;
		map<string, string>::iterator it = UID_map.find(dsp.name);
		if (it != UID_map.end()) {
			dsp.uid = it->second;
		}
		else {
			cout << "Warning: No UID found for " << dsp.name << endl;
		}
	}
	*/

	// Add dataset to datafile
	if (ds->datatype < 10)
		df->datasets.push_back(ds);

	// Unlock mutex to allow reading/writing to the dataset
	ds->mutex.unlock();

}


void ReadDatasets(char* buffer, size_t& cursor, uint32_t& element_size, H2A::Datafile* datafile, const bool& byte_swap)
{

	// Field name length
	std::vector<int32_t> field_name_length = ReadElement<int32_t>(buffer, cursor, byte_swap);

	// Field names
	bool uid_defined = false; // Is rewritten to True if UID is encountered
	std::vector<char> field_names_chars = ReadElement<char>(buffer, cursor, byte_swap);
	std::vector<std::string> field_names;
	std::string name_tmp;
	size_t name_len, j;

	for (int i = 1; i <= static_cast<int>(field_names_chars.size()); i++) {
		if (i % field_name_length[0] == 0) {
			name_tmp = std::string(&field_names_chars[static_cast<unsigned long>(i - field_name_length[0])], 32);
			name_len = name_tmp.size();
			j = 0;
			// Remove non alpha-numeric chars
			while (j < name_len) {
				if (!isalnum(name_tmp[j]) && name_tmp[j] != '_') {
					name_tmp.erase(j, 1);
					name_len--;
				}
				else {
					j++;
				}
			}
			field_names.push_back(name_tmp);
			if (name_tmp == "uid") uid_defined = true;
		}
	}

	// Parse datasets until buffer is fully read
	while (cursor < element_size)
		ReadDatasetElement(buffer, cursor, datafile, uid_defined, byte_swap);

}


void ReadMessages(char* buffer, size_t& cursor, const std::vector<int32_t>& dimensions, H2A::Datafile* df, const bool& byte_swap) {
	
	if (dimensions[0] != 12) { std::cout << "Warning: unexpexted number of rows in messages array" << std::endl; }
	Tag tag = ReadTag(&buffer[cursor], byte_swap);
	if (tag.type != 2) { std::cout << "Warning: unexpected datatype used for message array" << std::endl; }
	cursor += 8; // Tag has been read, skip over it

	// Read IDs, dTs and message data to arma rows and matrix
	arma::Mat<uint8_t> *message_mat = new arma::Mat<uint8_t>(8, static_cast<arma::uword>(dimensions[1]));
	arma::Row<uint16_t> *id_row = new arma::Row<uint16_t>(message_mat->n_cols);
	arma::Row<int16_t> *dt_row = new arma::Row<int16_t>(message_mat->n_cols);

	for (size_t col = 0; col < static_cast<size_t>(dimensions[1]); col++) {
		// Concatenate row 0 with 1 and 2 with 3 to form 16bit values for the message IDs and dTs
		id_row->at(col) = static_cast<uint16_t>(static_cast<uint8_t>(buffer[cursor + col * 12 + 1]) << 8) | static_cast<uint8_t>(buffer[cursor + col * 12 + 0]);
		dt_row->at(col) = static_cast<int16_t>(static_cast<uint8_t>(buffer[cursor + col * 12 + 3]) << 8) | static_cast<uint8_t>(buffer[cursor + col * 12 + 2]);
		
		// Message data
		for (uint8_t row = 0; row < 8; row++)
			message_mat->at(row, col) = static_cast<uint8_t>(buffer[cursor + static_cast<size_t>(col) * 12 + row + 4]);;
	}

	// First dT value is the (negative) offset between the startTime and the first message
	// This value is used to update the startTime of the dataset
	int16_t t_offset = dt_row->at(0);
	dt_row->at(0) = 0;
	// Todo: apply time offset on datafile startTime
	arma::Row<float> *time_row = new arma::Row<float>(dt_row->size());
	time_row->at(0) = 0.0;
	for (size_t col = 1; col < dt_row->size(); ++col)
		time_row->at(col) = time_row->at(col - 1) + (1.e-3 / H2A::INTCANLOG_SAMPLING_TIME) * static_cast<float>(dt_row->at(col));

	df->message_ids = id_row;
	df->message_time = time_row;
	df->messages = message_mat;

}



// Main function that parses the file
void H2A::Parsers::IntCanLog(const std::string& filename, H2A::Datafile *datafile)
{
	// Load MAT-file as generated by the car
	std::cout << "Loading " << filename << "..." << std::endl;

	//map<string, string> UID_map = GetUIDMap("C:/Users/dptre/Dropbox/Forze/Data/UIDs.txt");

	uint32_t filesize;

	char* data;
	char* buffer;
	size_t cursor, subcursor;
	bool byte_swap;

	// Read file into buffer
	std::ifstream input_file(filename, std::ios::in | std::ios::binary | std::ios::ate);

	if (input_file.is_open()) {

		// Determine file size and read to buffer
		filesize = input_file.tellg();
		std::cout << "Filesize: " << filesize << " bytes" << std::endl;
		input_file.seekg(0, std::ios::beg);
		data = new char[filesize];
		cursor = 0;
		input_file.read(data, filesize);
		input_file.close();
	}
	else { throw std::runtime_error("Failed to open file"); }

	// Lock datafile for writing
	datafile->mutex.lock();

	// Set datafile name
	std::vector<std::string> split_file;
	boost::split(split_file, filename, boost::is_any_of("/"));
	datafile->name = split_file.back();

	// Read header and determine endian with MI/IM indicator
	buffer = new char[128];
	CopyBytes(data, buffer, cursor, 128);
	byte_swap = buffer[126] == 'I';
	
	// 3 iteration to read startTime, datasets and messages
	for (int i = 0; i < 3; i++) {

		// Read tag
		delete[] buffer;
		buffer = new char[8];
		CopyBytes(data, buffer, cursor, 8);

		// Evaluate element type and size
		Tag tag = ReadTag(buffer, byte_swap);
		if (tag.small) throw std::runtime_error("Unexpected tag read (compressed format)");
		if (tag.type != 14) throw std::runtime_error("Unexpected tag read (expected type 14)");

		// Read struct described by tag
		delete[] buffer;
		buffer = new char[tag.size];
		CopyBytes(data, buffer, cursor, tag.size);
		
		subcursor = 0;
		std::vector<uint32_t> flags = ReadElement<uint32_t>(buffer, subcursor, byte_swap);
		std::vector<int32_t> dimensions = ReadElement<int32_t>(buffer, subcursor, byte_swap);
		std::vector<char> name = ReadElement<char>(buffer, subcursor, byte_swap);
		std::string element_name = std::string(name.begin(), name.end());
		
		// Start time
		if (element_name == "startTime") {
			std::vector<uint16_t> start_time = ReadElement<uint16_t>(buffer, subcursor, byte_swap);
			datafile->startTime = start_time;
		}
		
		// Datasets
		else if (element_name == "datasets") {
			ReadDatasets(buffer, subcursor, tag.size, datafile, byte_swap);
			std::cout << "Datasets: " << datafile->datasets.size() << " read" << std::endl;
		}
		
		// Messages
		else if (element_name == "messages") {
			ReadMessages(buffer, subcursor, dimensions, datafile, byte_swap);
			std::cout << "Messages: " << datafile->messages->n_cols << " read" << std::endl;;
		}
	}

	// Unlock datafile
	datafile->mutex.unlock();

	delete[] data;
	delete[] buffer;

	
	//datafile.populateDatasets();
	return;
}

/*

	map<string, string> Parser::GetUIDMap(const string & file)
	{
		cout << "Reading UID lookup" << endl;
		map<string, string> UID_map;
		fstream uid_file;
		uid_file.open(file, ios::in);
		if (uid_file.is_open())
		{
			string line;
			while (getline(uid_file, line))
			{
				string name = line.substr(11, line.size() - 13);
				string uid = line.substr(1, 6);
				UID_map[name] = uid;
			}

			uid_file.close();
		}
		return UID_map;
	}


}

*/
